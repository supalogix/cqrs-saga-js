{"version":3,"sources":["../src/aggregate-root.js"],"names":[],"mappings":";;;;;;;;AAAA;;;;AAEA,IAAM,4BAA4B,kDAAlC;AACA,IAAM,0BAAyB,SAAzB,uBAAyB;AAAA,QAAO;AACrC,QAAM;AAD+B,EAAP;AAAA,CAA/B;;AAIA,IAAM,uBAAuB,SAAvB,oBAAuB,GAAuB;AAAA,KAAtB,KAAsB,yDAAd,EAAc;AAAA,KAAV,KAAU;;AACnD,KAAI,MAAM,IAAN,KAAe,cAAnB,EACC,OAAO,EAAP;;AAED,KAAI,MAAM,IAAN,KAAe,yBAAnB,EACC,OAAO,EAAP;;AAED,QAAO,MAAM,MAAN,CAAa,KAAb,CAAP;AACA,CARD;;IAUqB,a;;;;;;;;;;;;;;;;;AAgBpB,wBAAY,MAAZ,EAAoB,kBAApB,EAAwC,YAAxC,EAAsD;AAAA;;AACrD,MAAM,WAAW,OAAO,MAAP,CAChB,UAAC,KAAD,EAAO,KAAP;AAAA,UAAiB,mBAAmB,KAAnB,EAAyB,KAAzB,CAAjB;AAAA,GADgB,EAEhB,YAFgB,CAAjB;;AAIA,MAAM,WAAW;AAChB,gBAAa,kBADG;AAEhB,kBAAe,oBAFC,EAAjB;AAGA,OAAK,KAAL,GAAa,wBAAY,4BAAgB,QAAhB,CAAZ,EAAuC,QAAvC,CAAb;AACA;;;;;;;;;;;;;;;;;;;;;;;;8BAsBW,K,EAAO;AAClB,QAAK,KAAL,CAAW,QAAX,CAAoB,KAApB;AACA;;;;;;;;;;;;;;;0CAYuB;AACvB,UAAO,KAAK,KAAL,CAAW,QAAX,GAAsB,aAA7B;AACA;;;;;;;;;;;;;2CAUwB;AACxB,QAAK,KAAL,CAAW,QAAX,CAAoB,yBAApB;AACA;;;sBA7CW;AACX,UAAO,KAAK,KAAL,CAAW,QAAX,GAAsB,WAA7B;AACA;;;;;;kBAhCmB,a","file":"aggregate-root.js","sourcesContent":["import { createStore, combineReducers } from \"redux\";\n\nconst MARK_CHANGES_AS_COMMITTED = \"@@cqrs-redux-js/events/MARK_CHANGES_AS_COMMITTED\";\nconst markChangesAsCommitted = () => ({\n\ttype: MARK_CHANGES_AS_COMMITTED\n})\n\nconst entityChangesReducer = (state = [], event) => {\n\tif( event.type === '@@redux/INIT' )\n\t\treturn [];\n\n\tif( event.type === MARK_CHANGES_AS_COMMITTED )\n\t\treturn [];\n\n\treturn state.concat(event);\n}\n\nexport default class AggregateRoot {\n\t/**\n\t * @param {array} events\n\t * @param {function} entityStateReducer\n\t * @param {function} initialState\n\t * @example <caption>Create Subclass</caption>\n\t * const initialState = {};\n\t * const reducer = (state, event) => {\n\t *\n\t * };\n\t * class DomainEntity extends AggregateRoot {\n\t *  constructor(events, props) {\n\t *    super(events, reducer, initialState);\n\t *  }\n\t * }\n\t */\n\tconstructor(events, entityStateReducer, initialState) {\n\t\tconst appState = events.reduce(\n\t\t\t(state,event) => entityStateReducer(state,event),\n\t\t\tinitialState);\n\n\t\tconst reducers = {\n\t\t\tentityState: entityStateReducer,\n\t\t\tentityChanges: entityChangesReducer };\n\t\tthis.store = createStore(combineReducers(reducers), appState);\n\t}\n\t\n\t/**\n\t * @return {object}\n\t */\n\tget state() {\n\t\treturn this.store.getState().entityState;\n\t}\n\n\t/**\n\t * We need a means of recording changes that happen to an aggregate\n\t * root.\n\t *\n\t * @param {object} event a domain event that you would like to save\n\t *\n\t * @example <caption>Add Domain Event to Entity Changes</caption>\n\t * this.applyChange({\n\t *   aggregateId: \"\",\n\t *   version: 1,\n\t *   type: ACCOUNT_CREATED\n\t * })\n\t */\n\tapplyChange(event) {\n\t\tthis.store.dispatch(event);\n\t}\n\n\t/**\n\t * Clients need a means of retrieving the changes that have happened\n\t * to an aggregate root.\n\t *\n\t * @return {array}\n\t *\n\t * @example <caption>Publish Domain Events</caption>\n\t * publisher.publish(entity.getUncommittedChanges())\n\t *\n\t */\n\tgetUncommittedChanges() {\n\t\treturn this.store.getState().entityChanges;\n\t}\n\n\t/**\n\t * An aggregate root needs to let clients clear all its domain events\n\t * once they have processed the domain events.\n\t *\n\t * @example <caption>Clear Domain Events After Publishing</caption>\n\t * publisher.publish(entity.getUncommittedChanges());\n\t * entity.markChangesAsCommitted();\n\t */\n\tmarkChangesAsCommitted() {\n\t\tthis.store.dispatch(markChangesAsCommitted());\n\t}\n}\n"]}